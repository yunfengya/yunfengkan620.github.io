<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>three.js css2d - label</title>
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			.label {
				color: #FFF;
				font-family: sans-serif;
				padding: 2px;
				background: rgba( 0, 0, 0, .6 );
			}
		</style>
	</head>
	<body>
		<!-- 
            基础语法的使用 
        -->
	</body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/",
                "OrbitControls": "../examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        // 导入轨道控制器
        // import { OrbitControls } from "../examples/jsm/controls/OrbitControls.js";
        // html中先通过 上面的引入 才能正确引入
        import { OrbitControls } from "OrbitControls";

        // console.log(THREE);

        // 目标：使用控制器查看3d物体

        // 1、创建场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color("white");

        // 2、创建相机
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        // 设置相机位置
        camera.position.set(0, 10, 30);
        scene.add(camera);

        // 6 纹理加载器
        const loader = new THREE.TextureLoader(); 
        {
            const planeSize = 40;
            const texture = loader.load('../manual/examples/resources/images/checker.png');
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            const repeats = planeSize / 2;
            texture.repeat.set(repeats, repeats);

            const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
            });
            planeMat.color.setRGB(1.5, 1.5, 1.5);
            const mesh = new THREE.Mesh(planeGeo, planeMat);
            mesh.rotation.x = Math.PI * -.5;
            scene.add(mesh);
        }
        // 我们将颜色设置为1.5, 1.5, 1.5，这将是棋盘纹理的颜色倍增 1.5，1.5，1.5。 
        // 也就是说纹理原本的颜色是 0x808080 和 0xC0C0C0，是灰色和浅灰色，现在灰色和浅灰色乘以 1.5 将得到白色和浅灰色的棋盘。
        // 现在让我们加载阴影贴图
        const shadowTexture = loader.load("../manual/examples/resources/images/roundshadow.png");
        // 创建一个数组来存放每个球体和它相关的对象
        const sphereShadowBases = [];
        // 现在我们创建一个球体
        const sphereRadius = 1;
        const sphereWidthDivisions = 32;
        const sphereHeightDivisions = 16;
        const sphereGeo = new THREE.SphereGeometry(
            sphereRadius,
            sphereWidthDivisions,
            sphereHeightDivisions
        );
        // 然后创建一个假阴影的平面网格
        const planeSize = 1;
        const shadowGeo = new THREE.PlaneGeometry(planeSize, planeSize);

        // 现在我们将创建一堆球体，对于每个球体都将创建一个基础的THREE.Object3D，
        // 并且我们将同时创建阴影平面网格和球体网格。这样，如果我们同时移动球体，
        // 阴影也一并移动，我们只需要将阴影稍微放置再地面上，防止 Z 轴阴影和地面重叠。 
        // 我们将depthWrite属性设置为 false，这样使阴影之间不会彼此混淆。 
        // 我们将在另一篇文章中讨论这两个问题。 因为阴影的材质是MeshBasicMaterial，所以它并不需要照明
        // 我们将每个球体使用不同的色相，然后保存每个球体的基础、球体网格、阴影网格和初始 y 位置。
        const numSpheres = 15;
        for (let i = 0; i < numSpheres; ++i) {
        // make a base for the shadow and the sphere
        // so they move together.
        const base = new THREE.Object3D();
        scene.add(base);

        // add the shadow to the base
        // note: we make a new material for each sphere
        // so we can set that sphere's material transparency
        // separately.
        const shadowMat = new THREE.MeshBasicMaterial({
            map: shadowTexture,
            transparent: true, // so we can see the ground
            depthWrite: false, // so we don't have to sort
        });
        const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
        shadowMesh.position.y = 0.001; // so we're above the ground slightly
        shadowMesh.rotation.x = Math.PI * -0.5;
        const shadowSize = sphereRadius * 4;
        shadowMesh.scale.set(shadowSize, shadowSize, shadowSize);
        base.add(shadowMesh);

        // add the sphere to the base
        const u = i / numSpheres; // goes from 0 to 1 as we iterate the spheres.
        const sphereMat = new THREE.MeshPhongMaterial();
        sphereMat.color.setHSL(u, 1, 0.75);
        const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
        sphereMesh.position.set(0, sphereRadius + 2, 0);
        base.add(sphereMesh);

        // remember all 3 plus the y position
        sphereShadowBases.push({
            base,
            sphereMesh,
            shadowMesh,
            y: sphereMesh.position.y,
        });
        }

        // 我们设置两个光源，一个是HemisphereLight，将其光照强度设置为 2，让场景比较明亮。
        {
            const skyColor = 0xb1e1ff; // light blue
            const groundColor = 0xb97a20; // brownish orange
            const intensity = 2;
            const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            scene.add(light);
        }
        // 另一个是 DirectionalLight ，这将让球体看起来有些视觉的区别
        {
            const color = 0xffffff;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.castShadow = true;
            light.position.set(0, 10, 5);
            light.target.position.set(-5, 0, 0);
            scene.add(light);
            scene.add(light.target);
        }
        // 
        // function render(time) {
            
        // }


        
        // 初始化渲染器
        const renderer = new THREE.WebGLRenderer();
        renderer.shadowMap.enabled = true;
        // 设置渲染的尺寸大小
        renderer.setSize(window.innerWidth, window.innerHeight);
        // console.log(renderer);
        // 将webgl渲染的canvas内容添加到body
        document.body.appendChild(renderer.domElement);

        // // 使用渲染器，通过相机将场景渲染进来
        // renderer.render(scene, camera);

        // 创建轨道控制器
        const controls = new OrbitControls(camera, renderer.domElement);

        // 添加坐标轴辅助器
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const dir = new THREE.Vector3( 1, 2, 0 );

        //箭头辅助器
        dir.normalize();

        const origin = new THREE.Vector3( 0, 0, 0 );
        const length = 1;
        const hex = 0xffff00;

        // 箭头辅助器 ArrowHelper用于模拟方向的3维箭头对象.
        const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
        scene.add( arrowHelper )
        
        // requestAnimationFrame的回调函数
        function renderFn(time) {
            time *= 0.001;  // convert to seconds
            sphereShadowBases.forEach((sphereShadowBase, ndx) => {
                const {base, sphereMesh, shadowMesh, y} = sphereShadowBase;

                // u is a value that goes from 0 to 1 as we iterate the spheres
                const u = ndx / sphereShadowBases.length;

                // compute a position for the base. This will move
                // both the sphere and its shadow
                const speed = time * .2;
                const angle = speed + u * Math.PI * 2 * (ndx % 1 ? 1 : -1);
                const radius = Math.sin(speed - ndx) * 10;
                base.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);

                // yOff is a value that goes from 0 to 1
                const yOff = Math.abs(Math.sin(time * 2 + ndx));
                // move the sphere up and down
                sphereMesh.position.y = y + THREE.MathUtils.lerp(-2, 2, yOff);
                // fade the shadow as the sphere goes up
                shadowMesh.material.opacity = THREE.MathUtils.lerp(1, .25, yOff);
            });
            
            
            
            renderer.render(scene, camera);
            //   渲染下一帧的时候就会调用renderFn函数
            requestAnimationFrame(renderFn);
        }

        renderFn(1);
    </script>
</html>
